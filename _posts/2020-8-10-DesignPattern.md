---
layout:     post
title:      "设计模式"
subtitle:   "前人的宝贵经验"
date:       2020-8-7
author:     "Burt"
header-img: "img/in-post/DP/DP-bg.png"
tags:
    - C#
---





## 前言

总结设计模式的博文，使用C#





## 设计原则

　	使用设计模式的根本原因是**适应变化**，**提高代码复用率**，使软件更具有**可维护性**和**可扩展性**。并且，在进行设计的时候，也需要遵循以下几个原则：单一职责原则、开放封闭原则、里氏代替原则、依赖倒置原则、接口隔离原则、合成复用原则和迪米特法则。下面就分别介绍了每种设计原则。

### 一、单一职责原则 SRP(Single Responsibilities Principle)

​		就一个类而言，应该只有一个引起它变化的原因。如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会影响到其他的职责，另外，把多个职责耦合在一起，也会影响复用性。

### 二、开闭原则 OCP(Open Close Principle)

​		该原则强调的是：一个软件实体（指的类、函数、模块等）应该**对扩展开放，对修改关闭**。即每次发生变化时，要通过添加新的代码来增强现有类型的行为，而不是修改原有的代码。

​		符合开闭原则的最好方式是提供一个固有的接口，然后让所有可能发生变化的类实现该接口，让固定的接口与相关对象进行交互。

### 三、里氏代替原则 LSK(Liskov Substitution Principle)

​		指的是**子类必须替换掉它们的父类型**。也就是说，在软件开发过程中，子类替换父类后，程序的行为是一样的。只有当子类替换掉父类后，此时软件的功能不受影响时，父类才能真正地被复用，而子类也可以在父类的基础上添加新的行为。

### 四、依赖倒置原则 DIP(Dependence Inversion Principle)

　　依赖倒置，原则指的是**抽象不应该依赖于细节**，**细节应该依赖于抽象**，也就是提出的 “面向接口编程，而不是面向实现编程”。这样可以降低客户与具体实现的耦合。

### 五、合成复用原则 CRP(Composite Reuse Principle)

　　合成复用原则，就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分。新对象通过向这些对象的委派达到复用已用功能的目的。简单地说，就是要尽量使用合成/聚合，尽量不要使用继承。

### 六、迪米特法则 LoD(Law of Demeter)

　　迪米特法则，又叫最少知识原则（Least Knowledge  Principle，LKP），指的是一个对象应当对其他对象有尽可能少的了解。也就是说，一个模块或对象应尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立，这样当一个模块修改时，影响的模块就会越少，扩展起来更加容易。

　　关于迪米特法则其他的一些表述有：只与你直接的朋友们通信；不要跟“陌生人”说话。

　　外观模式（Facade Pattern)和中介者模式（Mediator Pattern）就使用了迪米特法则。



## 创建型模式

创建型模式就是用来创建对象的模式，抽象了实例化的过程。所有的创建型模式都有两个共同点。第一，它们都将系统使用哪些具体类的信息封装起来；第二，它们隐藏了这些类的实例是如何被创建和组织的。创建型模式包括：

- 单例模式：解决的是实例化对象的个数的问题，比如抽象工厂中的工厂、对象池等，除了Singleton之外，其他创建型模式解决的都是 new 所带来的耦合关系。
- 抽象工厂：创建一系列相互依赖对象，并能在运行时改变系列。
- 工厂方法：创建单个对象，在Abstract Factory有使用到。
- 原型模式：通过拷贝原型来创建新的对象。

 单例模式，工厂方法，抽象工厂都需要一个额外的工厂类来负责实例化“一个对象”，而原型模式则是通过原型（一个特殊的工厂类）来克隆“易变对象”。

总结：关注**对象怎么来**

### 一、单例模式（Singleton Pattern）

单例模式指的是确保某一个类只有一个实例，并提供一个全局访问点。解决的是实体对象个数的问题，而其他的建造者模式都是解决new所带来的耦合关系问题。其实现要点有：**类只有一个实例**。操作系统中只能有一个任务管理器,操作文件时,同一时间内只允许一个实例对其操作等。

- 意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。
- 主要解决：一个全局使用的类频繁地创建与销毁。
- 何时使用：当您想控制实例数目，节省系统资源的时候。
- 如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。
- 关键代码：构造函数是私有的。

**实现形式：**

#### 1.懒汉式，线程不安全

- 描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。这种方式 lazy loading很明显，不要求线程安全，在多线程不能正常工作。
- 是否 Lazy 初始化：是
- 是否多线程安全：否

~~~c#
public class Singleton{
    
    public static Singleton instance;
    //不允许外界访问构造函数
    private Singleton (){}  
    
    //只允许外界使用该方法创建
    public static Singleton getInstance() {  
    	if (instance == null)	instance = new Singleton();  
    	return instance;  
    }  
}
~~~

**接下来介绍的几种实现方式都支持多线程，但是在性能上有所差异。**

#### 2.懒汉式，线程安全

- 描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。
- 是否 Lazy 初始化：是
- 是否多线程安全：是
- 优点：第一次调用才初始化，避免内存浪费。
- 缺点：必须加锁`lock`才能保证单例，但加锁会影响效率。getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。

~~~c#
public class Singleton {  
    
    private static Singleton instance;  
    //不允许外界访问构造函数
    private Singleton (){}  
    
    //只允许外界使用该方法创建
    public static Singleton getInstance() {  
       	 //如果类的实例不存在则创建，否则直接返回if (instance == null)
		if (instance == null) {  
			lock (locker)
         	{
				instance  = new Singleton();
			}
    	}  
    }  
}
~~~

#### 3.饿汉式

- 描述：这种方式比较常用，但容易产生垃圾对象。
- 是否 Lazy 初始化：否
- 是否多线程安全：是
- 优点：没有加锁，执行效率会提高。
- 缺点：类加载时就初始化，浪费内存。

~~~c#

public class Singleton {  
    //提前实例化
    private static Singleton instance = new Singleton(); 
    //不允许外界访问构造函数
    private Singleton (){}  
    //只允许外界使用该方法创建
    public static Singleton getInstance() {  
    	return instance;  
    }  
}
~~~

PS：

- 懒汉式与饿汉式的根本区别在与是否在类内方法外创建自己的对象。
- 并且声明对象都需要私有化，构造方法都要私有化，这样外部才不能通过 new 对象的方式来访问。饿汉式的话是声明并创建对象(因为他饿)，懒汉式的话只是声明对象，在调用该类的 getinstance() 方法时才会进行 new 对象。

这就结束了对单例模式的解释。



### 二、工厂模式（Factory Pattern）

**意图：**定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。

**主要解决：**主要解决接口选择的问题。

**何时使用：**我们明确地计划不同条件下创建不同实例时。

**如何解决：**让其子类实现工厂接口，返回的也是一个抽象的产品。

**关键代码：**创建过程在其子类执行。





## 创建型模式

总结：**对象和谁有关**







## 行为型模式

总结：**对象与对象在干嘛**